import chalk from 'chalk';
import ora from 'ora';
import { ConfigManager } from '../cli/ConfigManager.js';
import { SQLiteSecretStorage } from '../storage/SecretStorage.js';
import { DefaultCryptoProvider } from '../crypto/CryptoProvider.js';
import { writeFile, readFile } from 'fs/promises';

/**
 * Inject encrypted secrets into target files
 */
export async function injectCommand(options: { env: string; file?: string }): Promise<void> {
  const configManager = new ConfigManager();

  // Check if initialized
  if (!(await configManager.exists())) {
    console.log(chalk.red('‚ùå SecretForge not initialized. Run `sf init` first.'));
    return;
  }

  if (!options.env) {
    console.log(chalk.red('‚ùå Environment is required. Use --env <environment>'));
    return;
  }

  const config = await configManager.load();
  const spinner = ora('Injecting secrets...').start();

  try {
    // Initialize storage
    const cryptoProvider = new DefaultCryptoProvider();
    const storage = new SQLiteSecretStorage(configManager.getDatabasePath(config), cryptoProvider);

    // Get secrets for the environment
    const secrets = await storage.listSecrets({
      project: config.project,
      environment: options.env,
    });

    if (secrets.length === 0) {
      spinner.warn(`No secrets found for environment: ${options.env}`);
      storage.close();
      return;
    }

    // Decrypt secrets
    const decryptedSecrets: Record<string, string> = {};
    for (const secret of secrets) {
      const value = await storage.decryptSecret(secret);
      decryptedSecrets[secret.name] = value;
    }

    // Determine output file
    const outputFile = options.file || `.env.${options.env}`;

    // Read existing file if it exists
    let existingContent = '';
    try {
      existingContent = await readFile(outputFile, 'utf-8');
    } catch {
      // File doesn't exist, that's okay
    }

    // Parse existing content
    const existingVars = new Map<string, string>();
    existingContent.split('\n').forEach((line) => {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, ...valueParts] = trimmed.split('=');
        if (key) {
          existingVars.set(key.trim(), valueParts.join('='));
        }
      }
    });

    // Merge with secrets
    for (const [name, value] of Object.entries(decryptedSecrets)) {
      existingVars.set(name, value);
    }

    // Build output content
    const lines: string[] = [
      `# Generated by SecretForge - ${new Date().toISOString()}`,
      `# Environment: ${options.env}`,
      '',
    ];

    for (const [key, value] of existingVars.entries()) {
      // Escape value if it contains special characters
      const needsQuotes = /[\s#]/.test(value);
      if (needsQuotes) {
        // Escape quotes and backslashes for shell
        const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        lines.push(`${key}="${escaped}"`);
      } else {
        lines.push(`${key}=${value}`);
      }
    }

    // Write to file
    await writeFile(outputFile, lines.join('\n') + '\n', 'utf-8');

    spinner.succeed(`Secrets injected into ${outputFile}`);

    console.log(chalk.bold('\nüìã Injected Secrets:'));
    secrets.forEach((secret) => {
      console.log(chalk.gray(`  ‚Ä¢ ${secret.name}`));
    });

    console.log(chalk.yellow(`\n‚ö†Ô∏è  Remember to add ${outputFile} to your .gitignore`));

    storage.close();
  } catch (error) {
    spinner.fail('Failed to inject secrets');
    throw error;
  }
}
